98
Chapter 5 Efficient Compilation of Pattern-matching
Notice that G, and Ar cannot be equal to FAIL, because they are only the
transformed versions of expressions written by the programmer.
If the right-hand side is of the first form, we can use the third rule of the
previous section repeatedly, followed by the second, to give:
(IF G1 A1 (IF ... (IF Gg Ag FAIL) ... )) I E
IF G1 A1 (IF . . . (IF Gg Ag E) . . . )
If the right-hand side is of the second form, it cannot return FAIL, and so we
can use the first rule of the previous section.
Application of these three rules will eliminate all occurrences of I and FAIL
in the expression generated by the empty rule, and incidentally thereby give a
worthwhile improvement in efficiency.
5.4.2.3 Clever compilation
Using these rules, many of the instances of I and FAIL remaining in a function
definition can be eliminated. Later we will consider compiling an expression
into low-level machine code. When we do this, we will see that it is possible to
compile the remaining expressions involving I and FAIL in a surprisingly
efficient way, so that I requires no code at all, and the FAIL simply compiles to
a jump instruction. This is discussed in Section 20.4.
5.5 Uniform Definitions
This section introduces a restricted class of function definitions, called
uniform definitions. There are two motivations for studying this class. First,
uniform definitions avoid certain problems with reasoning about function
definitions that involve pattern-matching. Second, uniform definitions are
easier to compile, and are guaranteed to avoid certain kinds of inefficient
code.
We begin by discussing some problems with reasoning about function
definitions containing pattern-matching. Consider again the alternate
definition of mappairs:
mappairs' f [] ys
mappairs' f xs []
=
mappairs' f (x:xs) (y:ys) = f x y : mappairs' f xs ys
Now, consider evaluation of the expression:
mappairs' (+) bottom []
where the evaluation of bottom would fail to terminate (for example, bottom
could be defined by the degenerate equation bottom = bottom). Matching
against the first equation binds f to (+) and then attempts to match [] against
