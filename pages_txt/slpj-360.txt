362
Chapter 20 Optimizations to the G-machine
UPDCONS). Furthermore the optimization can also be applied to the updates
performed by CLetrec.
We could describe the optimization by modifying the RS and CLetrec
compilation schemes, in the manner indicated above, to generate UPDAP and
UPDCONS instructions. This description has two disadvantages:
(i) It complicates the compilation schemes. In particular, we will have to
introduce a brand new scheme to handle the top level of CLetrec (try it!).
(ii) It is quite a low-level optimization to be allowed to clutter up the
compilation schemes.
Fortunately, we can describe it in quite a different way. All we are really doing
is performing the optimization
MKAP n; UPDATE d => MKAP (n-1); UPDAP (d+1)
which is precisely the sort of thing that a peephole optimizer could spot.
Accordingly, we choose to implement the optimization in the code generator.
There is also the related optimization
CONS n; UPDATE d => CONS (n-1); UPDCONS (d+1)
Notice that this description automatically catches cases generated by
CLetrec as well as R, and will also optimize the definition of the $CONS built-in
function (Section 18.8.2).
20.10.4 Unpacking Structured Objects
The compilation of case-expressions, using the optimization described in
Section 6.3.3, resulted in the frequent occurrence of expressions such as
let
V1 = SEL-SUM-k-1 v
in E
VK = SEL-SUM-k-k v
where v, Vi, ..., Vk are variables. If this is compiled by the R scheme in a
context in which v is evaluated, normally by an enclosing CASE function, we
will get the following G-code:
PUSH (d - p v); SELSUM k,1;
PUSH (d+k-1 - p V); SELSUM k,k;
RI E 1 p' (d+k)
where p' = p[vi=d+1,..., Vn=d+k]. (We are assuming here that the
optimization which avoids repeated EVALs described in Section 20.6 is
implemented, so that no EVALs precede the SELSUM instructions; and that the
optimization which performs eager evaluation of applications of SEL-SUM-k-i
described in Section 20.8 is also implemented.)
