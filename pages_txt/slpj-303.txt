Section 18.5 Compiling a supercombinator definition
305
We must now describe what R does. As we saw in our example, the code for
a supercombinator has to do four things:
(i) construct an instance of the supercombinator body, using the parameters
on the stack;
(ii) update the root of the redex with a copy of the root of the result (note:
there are the usual complications if the body consists of a single variable,
which we deal with later);
(iii) remove the parameters from the stack;
(iv) initiate the next reduction.
This translates directly into a compilation scheme for R:
R[[ E ] pd = CI[ E ]] p d; UPDATE (d+1); POP d; UNWIND
We use another auxiliary function, C (for Construct Instance), which
produces code to construct an instance of E and put a pointer to it on the stack,
which constitutes step (i). The UPDATE instruction overwrites the root of the
redex (which is now at offset (d+1) from the top of the stack) with the newly
created instance, which is currently on top of the stack (step (ii)); UPDATE
then pops it from the stack. Then the POP instruction pops the arguments (step
(iii)), and the UNWIND instruction initiates the next reduction (step (iv)).
Figure 18.7 summarizes the F and R compilation schemes.
Warning: while it will give the correct results, the code generated by R may
give bad performance for projection functions, such as
fxyz = y
where the body of the function consists of a single variable. The reasons for
this were explained in Section 12.4. As given, the UPDATE instruction
generated by the R scheme will copy the root of the argument y, without first
evaluating it. This risks duplicating the root of a redex, which would lose
laziness. We will fix this problem in the next version of R, at the beginning of
Chapter 20.
All we have left to do is to describe the C compilation scheme.
F[ SCDef ]
generates code for a supercombinator definition SCDef.
F[[ f x1 x2 . . . Xn = E ] = GLOBSTART f n;
RI E ] [x1=n, X2=n-1, . . ., Xn=1] n
RI E 1 pd
generates code to apply a supercombinator to its arguments.
Note: there are d arguments.
R[ E ] pd = C[[ E ] p d; UPDATE (d+1); POP d; UNWIND
Figure 18.7 The R compilation scheme
