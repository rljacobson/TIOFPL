
@article{robinson_machine-oriented_1965,
	title = {A {Machine}-{Oriented} {Logic} {Based} on the {Resolution} {Principle}},
	volume = {12},
	issn = {0004-5411},
	url = {http://doi.acm.org/10.1145/321250.321253},
	doi = {10.1145/321250.321253},
	language = {en},
	number = {1},
	urldate = {2019-07-20},
	journal = {Journal of the ACM},
	author = {Robinson, J. A.},
	month = jan,
	year = {1965},
	pages = {23--41},
	file = {Robinson (1965) - A Machine-Oriented Logic Based on the Resolution Principle.pdf:/Users/rljacobson/Zotero/storage/XFX7ZD3X/Robinson (1965) - A Machine-Oriented Logic Based on the Resolution Principle.pdf:application/pdf},
}

@article{landin_next_1966,
	title = {The {Next} 700 {Programming} {Languages}},
	volume = {9},
	issn = {0001-0782},
	url = {http://doi.acm.org/10.1145/365230.365257},
	doi = {10.1145/365230.365257},
	abstract = {A family of unimplemented computing languages is described that is intended to span differences of application area by a unified framework. This framework dictates the rules about the uses of user-coined names, and the conventions about characterizing functional relationships. Within this framework the design of a specific language splits into two independent parts. One is the choice of written appearances of programs (or more generally, their physical representation). The other is the choice of the abstract entities (such as numbers, character-strings, list of them, functional relations among them) that can be referred to in the language.
The system is biased towards “expressions” rather than “statements.” It includes a nonprocedural (purely functional) subsystem that aims to expand the class of users' needs that can be met by a single print-instruction, without sacrificing the important properties that make conventional right-hand-side expressions easy to construct and understand.},
	number = {3},
	journal = {Commun. ACM},
	author = {Landin, P. J.},
	month = mar,
	year = {1966},
	pages = {157--166},
	file = {Landin (1966) - The Next 700 Programming Languages.pdf:/Users/rljacobson/Zotero/storage/TKW647ZW/Landin (1966) - The Next 700 Programming Languages.pdf:application/pdf},
}

@article{backus_can_1978,
	title = {Can {Programming} {Be} {Liberated} from the von {Neumann} {Style}? {A} {Functional} {Style} and {Its} {Algebra} of {Programs}},
	volume = {21},
	issn = {0001-0782},
	shorttitle = {Can programming be liberated from the von {Neumann} style?},
	url = {https://doi.org/10.1145/359576.359579},
	doi = {10.1145/359576.359579},
	abstract = {Conventional programming languages are growing ever more enormous, but not stronger. Inherent defects at the most basic level cause them to be both fat and weak: their primitive word-at-a-time style of programming inherited from their common ancestor—the von Neumann computer, their close coupling of semantics to state transitions, their division of programming into a world of expressions and a world of statements, their inability to effectively use powerful combining forms for building new programs from existing ones, and their lack of useful mathematical properties for reasoning about programs.An alternative functional style of programming is founded on the use of combining forms for creating programs. Functional programs deal with structured data, are often nonrepetitive and nonrecursive, are hierarchically constructed, do not name their arguments, and do not require the complex machinery of procedure declarations to become generally applicable. Combining forms can use high level programs to build still higher level ones in a style not possible in conventional languages.Associated with the functional style of programming is an algebra of programs whose variables range over programs and whose operations are combining forms. This algebra can be used to transform programs and to solve equations whose “unknowns” are programs in much the same way one transforms equations in high school algebra. These transformations are given by algebraic laws and are carried out in the same language in which programs are written. Combining forms are chosen not only for their programming power but also for the power of their associated algebraic laws. General theorems of the algebra give the detailed behavior and termination conditions for large classes of programs.A new class of computing systems uses the functional programming style both in its programming language and in its state transition rules. Unlike von Neumann languages, these systems have semantics loosely coupled to states—only one state transition occurs per major computation.},
	language = {en},
	number = {8},
	journal = {Communications of the ACM},
	author = {Backus, John},
	month = aug,
	year = {1978},
	note = {Place: New York, NY, USA
Publisher: Association for Computing Machinery},
	keywords = {algebra of programs, applicative computing systems, applicative state transition systems, combining forms, functional forms, functional programming, metacomposition, models of computing systems, program correctness, program termination, program transformation, programming languages, von Neumann computers, von Neumann languages},
	pages = {613--641},
	file = {Full Text:/Users/rljacobson/Zotero/storage/FR2LLNVK/Backus - 1978 - Can programming be liberated from the von Neumann .pdf:application/pdf},
}

@inproceedings{johnsson_efficient_1984,
	address = {New York, NY, USA},
	series = {{SIGPLAN} '84},
	title = {Efficient compilation of lazy evaluation},
	isbn = {978-0-89791-139-9},
	url = {https://doi.org/10.1145/502874.502880},
	doi = {10.1145/502874.502880},
	abstract = {This paper describes the principles underlying an efficient implementation of a lazy functional language, compiling to code for ordinary computers. It is based on combinator-like graph reduction: the user defined functions are used as rewrite rules in the graph. Each function is compiled into an instruction sequence for an abstract graph reduction machine, called the G-machine, the code reduces a function application graph to its value. The G-machine instructions are then translated into target code. Speed improvements by almost two orders of magnitude over previous lazy evaluators have been measured; we provide some performance figures.},
	urldate = {2021-12-31},
	booktitle = {Proceedings of the 1984 {SIGPLAN} symposium on {Compiler} construction},
	publisher = {Association for Computing Machinery},
	author = {Johnsson, Thomas},
	month = jun,
	year = {1984},
	pages = {58--69},
}

@inproceedings{peyton-jones_directions_1984,
	address = {Fai},
	series = {{SERC}},
	title = {Directions in functional programming research},
	language = {English},
	booktitle = {Distriibuted {Computing} {Systems} {Programme}},
	publisher = {Peter Peregrinus, Ltd.},
	author = {Peyton-Jones, Simon L.},
	editor = {Duce, D. A.},
	year = {1984},
	pages = {220--249},
}

@phdthesis{wadsworth_semantics_1971,
	title = {Semantics and {Pragmatics} of the {Lambda}-{Calculus}.},
	language = {English},
	school = {University of Oxford},
	author = {Wadsworth, C. P},
	year = {1971},
	note = {OCLC: 1083190807},
}

@book{abelson_structure_1985,
	address = {Cambridge, MA, USA},
	title = {Structure and interpretation of computer programs},
	isbn = {978-0-262-01077-1},
	publisher = {MIT Press},
	author = {Abelson, Harold and Sussman, Gerald Jay and Sussman, Julie},
	year = {1985},
}

@inproceedings{augustsson_compiler_1984,
	address = {New York, NY, USA},
	series = {{LFP} '84},
	title = {A compiler for lazy {ML}},
	isbn = {978-0-89791-142-9},
	url = {https://doi.org/10.1145/800055.802038},
	doi = {10.1145/800055.802038},
	abstract = {LML is a strongly typed, statically scoped functional Language with Lazy evaluation. It is compiled trough a number of program transformations which makes the code generation easier. Code is generated in two steps, first code for an abstract graph manipulation machine, the G-machine. From this code machine code is generated. Some benchmark tests are also presented.},
	language = {en},
	urldate = {2021-12-31},
	booktitle = {Proceedings of the 1984 {ACM} {Symposium} on {LISP} and functional programming},
	publisher = {Association for Computing Machinery},
	author = {Augustsson, Lennart},
	month = aug,
	year = {1984},
	pages = {218--227},
}

@inproceedings{burstall_hope_1980,
	address = {New York, NY, USA},
	series = {{LFP} '80},
	title = {{HOPE}: {An} experimental applicative language},
	isbn = {978-1-4503-7396-8},
	shorttitle = {{HOPE}},
	url = {https://doi.org/10.1145/800087.802799},
	doi = {10.1145/800087.802799},
	abstract = {An applicative language called HOPE is described and discussed. The underlying goal of the design and implementation effort was to produce a very simple programming language which encourages the construction of clear and manipulable programs. HOPE does not include an assignment statement; this is felt to be an important simplification. The user may freely define his own data types, without the need to devise a complicated encoding in terms of low-level types. The language is very strongly typed, and as implemented it incorporates a typechecker which handles polymorphic types and overloaded operators. Functions are defined by a set of recursion equations; the left-hand side of each equation includes a pattern used to determine which equation to use for a given argument. The availability of arbitrary higher-order types allows functions to be defined which 'package' recursion. Lazily-evaluated lists are provided, allowing the use of infinite lists which could be used to provide interactive input/output and concurrency. HOPE also includes a simple modularisation facility which may be used to protect the implementation of an abstract data type.},
	urldate = {2021-12-31},
	booktitle = {Proceedings of the 1980 {ACM} conference on {LISP} and functional programming},
	publisher = {Association for Computing Machinery},
	author = {Burstall, R. M. and MacQueen, D. B. and Sannella, D. T.},
	month = aug,
	year = {1980},
	pages = {136--143},
}

@inproceedings{chambers_functional_1984,
	address = {London; Orlando, FL},
	title = {Functional programming},
	url = {https://www.osti.gov/biblio/6089777},
	abstract = {BOOK 
CONTENTS: The Dataflow Approach: Fundamentals of dataflow. Architecture and performance. Assembler level programming. High level dataflow programming. Declarative systems: Functional programming. Logic programming and prolog. The ''language first'' approach. Towards a successor to von Neumann. Loosely-coupled systems: Architectures. Communications. Distributed filestores. Mechanisms for distributed control. Distributed operating systems. Programming languages. Closely-coupled systems: Architecture. Programming languages. Run-time support. Development aids. Cyba-M. Polyproc. Modeling and verification: Using algebra for concurrency. Reasoning about concurrent systems. Each chapter includes references. Index.},
	language = {English},
	urldate = {2022-01-01},
	booktitle = {Distributed {Computing}},
	publisher = {Academic Press},
	editor = {Chambers, F. B. and Duce, D. A. and Jones, G. P. and Darlingotn, J.},
	month = aug,
	year = {1984},
	file = {Snapshot:/Users/rljacobson/Zotero/storage/TUTN38RN/6089777.html:text/html},
}

@techreport{fairbairn_design_1985,
	type = {{PhD} {Thesis}},
	title = {Design and implementation of a simple typed language based on the lambda-calculus},
	url = {https://www.cl.cam.ac.uk/techreports/UCAM-CL-TR-75.html},
	language = {en},
	number = {UCAM-CL-TR-75},
	urldate = {2022-01-01},
	institution = {University of Cambridge, Computer Laboratory},
	author = {Fairbairn, Jon},
	month = may,
	year = {1985},
	note = {Accepted: 1984
ISSN: 1476-2986},
	file = {Full Text PDF:/Users/rljacobson/Zotero/storage/DWCXUVPT/Fairbairn - 1985 - Design and implementation of a simple typed langua.pdf:application/pdf;Snapshot:/Users/rljacobson/Zotero/storage/D4TJNG3B/UCAM-CL-TR-75.html:text/html},
}

@book{gordon_edinburgh_1979,
	address = {Berlin, Heidelberg},
	series = {Lecture {Notes} in {Computer} {Science}},
	title = {Edinburgh {LCF}},
	volume = {78},
	isbn = {978-3-540-09724-2 978-3-540-38526-4},
	url = {http://link.springer.com/10.1007/3-540-09724-4},
	urldate = {2022-01-01},
	publisher = {Springer Berlin Heidelberg},
	author = {Gordon, Michael J. and Milner, Arthur J. and Wadsworth, Christopher P.},
	editor = {Goos, G. and Hartmanis, J. and Brauer, W. and Brinch Hansen, P. and Gries, D. and Moler, C. and Seegmüller, G. and Stoer, J. and Wirth, N.},
	year = {1979},
	doi = {10.1007/3-540-09724-4},
}

@incollection{lindley_recursion_1982,
	address = {Cham},
	title = {Recursion {Equations} as a {Programming} {Language}},
	volume = {9600},
	isbn = {978-3-319-30935-4 978-3-319-30936-1},
	url = {http://link.springer.com/10.1007/978-3-319-30936-1_24},
	urldate = {2022-01-01},
	booktitle = {A {List} of {Successes} {That} {Can} {Change} the {World}},
	publisher = {Springer International Publishing},
	author = {Turner, D. A.},
	editor = {Lindley, Sam and McBride, Conor and Trinder, Phil and Sannella, Don},
	year = {1982},
	doi = {10.1007/978-3-319-30936-1_24},
	note = {Series Title: Lecture Notes in Computer Science},
	pages = {459--478},
}

@incollection{goos_miranda_1985,
	address = {Berlin, Heidelberg},
	title = {Miranda: {A} non-strict functional language with polymorphic types},
	volume = {201},
	isbn = {978-3-540-15975-9 978-3-540-39677-2},
	shorttitle = {Miranda},
	url = {http://link.springer.com/10.1007/3-540-15975-4_26},
	urldate = {2022-01-01},
	booktitle = {Functional {Programming} {Languages} and {Computer} {Architecture}},
	publisher = {Springer Berlin Heidelberg},
	author = {Turner, D. A.},
	editor = {Goos, G. and Hartmanis, J. and Barstow, D. and Brauer, W. and Brinch Hansen, P. and Gries, D. and Luckham, D. and Moler, C. and Pnueli, A. and Seegmüller, G. and Stoer, J. and Wirth, N. and Jouannaud, Jean-Pierre},
	year = {1985},
	doi = {10.1007/3-540-15975-4_26},
	note = {Series Title: Lecture Notes in Computer Science},
	pages = {1--16},
}

@inproceedings{rosser_highlights_1982,
	address = {Pittsburgh, Pennsylvania, United States},
	title = {Highlights of the history of the lambda-calculus},
	isbn = {978-0-89791-082-8},
	url = {http://portal.acm.org/citation.cfm?doid=800068.802153},
	doi = {10.1145/800068.802153},
	language = {en},
	urldate = {2022-01-01},
	booktitle = {Proceedings of the 1982 {ACM} symposium on {LISP} and functional programming  - {LFP} '82},
	publisher = {ACM Press},
	author = {Rosser, J. Barkley},
	year = {1982},
	pages = {216--225},
}

@article{schonfinkel_uber_1924,
	title = {Über die {Bausteine} der mathematischen {Logik}},
	volume = {92},
	issn = {0025-5831, 1432-1807},
	url = {http://link.springer.com/10.1007/BF01448013},
	doi = {10.1007/BF01448013},
	language = {de},
	number = {3-4},
	urldate = {2022-01-01},
	journal = {Mathematische Annalen},
	author = {Schönfinkel, M.},
	month = sep,
	year = {1924},
	pages = {305--316},
	file = {Springer Full Text PDF:/Users/rljacobson/Zotero/storage/KPP2GTHF/Schönfinkel - 1924 - Über die Bausteine der mathematischen Logik.pdf:application/pdf},
}

@article{staples_computation_1980,
	title = {Computation on graph-like expressions},
	volume = {10},
	issn = {03043975},
	url = {https://linkinghub.elsevier.com/retrieve/pii/0304397580900134},
	doi = {10.1016/0304-3975(80)90013-4},
	language = {en},
	number = {2},
	urldate = {2022-01-01},
	journal = {Theoretical Computer Science},
	author = {Staples, John},
	month = feb,
	year = {1980},
	pages = {171--185},
}

@article{staples_optimal_1980,
	title = {Optimal evaluations of graph-like expressions},
	volume = {10},
	issn = {03043975},
	url = {https://linkinghub.elsevier.com/retrieve/pii/0304397580900511},
	doi = {10.1016/0304-3975(80)90051-1},
	language = {en},
	number = {3},
	urldate = {2022-01-01},
	journal = {Theoretical Computer Science},
	author = {Staples, John},
	year = {1980},
	pages = {297--316},
}

@article{staples_speeding_1980,
	title = {Speeding up subtree replacement systems},
	volume = {11},
	issn = {03043975},
	url = {https://linkinghub.elsevier.com/retrieve/pii/030439758090033X},
	doi = {10.1016/0304-3975(80)90033-X},
	language = {en},
	number = {1},
	urldate = {2022-01-01},
	journal = {Theoretical Computer Science},
	author = {Staples, John},
	month = may,
	year = {1980},
	pages = {39--47},
}

@book{gordon_denotational_1979,
	address = {New York, NY},
	title = {The {Denotational} {Description} of {Programming} {Languages}},
	isbn = {978-0-387-90433-7 978-1-4612-6228-2},
	url = {http://link.springer.com/10.1007/978-1-4612-6228-2},
	language = {en},
	urldate = {2022-01-01},
	publisher = {Springer New York},
	author = {Gordon, Michael J. C.},
	year = {1979},
	doi = {10.1007/978-1-4612-6228-2},
}

@article{burstall_proving_1969,
	title = {Proving {Properties} of {Programs} by {Structural} {Induction}},
	volume = {12},
	issn = {0010-4620, 1460-2067},
	url = {https://academic.oup.com/comjnl/article-lookup/doi/10.1093/comjnl/12.1.41},
	doi = {10.1093/comjnl/12.1.41},
	language = {en},
	number = {1},
	urldate = {2022-01-01},
	journal = {The Computer Journal},
	author = {Burstall, R. M.},
	month = feb,
	year = {1969},
	pages = {41--48},
}

@article{burstall_transformation_1977,
	title = {A {Transformation} {System} for {Developing} {Recursive} {Programs}},
	volume = {24},
	issn = {0004-5411, 1557-735X},
	url = {https://dl.acm.org/doi/10.1145/321992.321996},
	doi = {10.1145/321992.321996},
	abstract = {A system of rules for transforming programs is described, with the programs in the form of recursion equations. An initially very simple, lucid, and hopefully correct program is transformed into a more efficient one by altering the recursion structure. Illustrative examples of program transformations are given, and a tentative implementation is described. Alternative structures for programs are shown, and a possible initial phase for an automatic or semiautomatic program-manipulation system is indicated.},
	language = {en},
	number = {1},
	urldate = {2022-01-01},
	journal = {Journal of the ACM},
	author = {Burstall, R. M. and Darlington, John},
	month = jan,
	year = {1977},
	pages = {44--67},
	file = {Submitted Version:/Users/rljacobson/Zotero/storage/55CXB9LL/Burstall and Darlington - 1977 - A Transformation System for Developing Recursive P.pdf:application/pdf},
}

@incollection{broy_algebras_1982,
	address = {Dordrecht},
	title = {Algebras, {Theories} and {Freeness}: {An} {Introduction} for {Computer} {Scientists}},
	isbn = {978-90-277-1462-6 978-94-009-7893-5},
	shorttitle = {Algebras, {Theories} and {Freeness}},
	url = {http://link.springer.com/10.1007/978-94-009-7893-5_11},
	urldate = {2022-01-01},
	booktitle = {Theoretical {Foundations} of {Programming} {Methodology}},
	publisher = {Springer Netherlands},
	author = {Burstall, R. M. and Goguen, J. A.},
	editor = {Broy, Manfred and Schmidt, Gunther},
	year = {1982},
	doi = {10.1007/978-94-009-7893-5_11},
	pages = {329--349},
}

@incollection{goos_compiling_1985,
	address = {Berlin, Heidelberg},
	title = {Compiling pattern matching},
	volume = {201},
	isbn = {978-3-540-15975-9 978-3-540-39677-2},
	url = {http://link.springer.com/10.1007/3-540-15975-4_48},
	urldate = {2022-01-01},
	booktitle = {Functional {Programming} {Languages} and {Computer} {Architecture}},
	publisher = {Springer Berlin Heidelberg},
	author = {Augustsson, Lennart},
	editor = {Goos, G. and Hartmanis, J. and Barstow, D. and Brauer, W. and Brinch Hansen, P. and Gries, D. and Luckham, D. and Moler, C. and Pnueli, A. and Seegmüller, G. and Stoer, J. and Wirth, N. and Jouannaud, Jean-Pierre},
	year = {1985},
	doi = {10.1007/3-540-15975-4_48},
	note = {Series Title: Lecture Notes in Computer Science},
	pages = {368--381},
}

@article{milner_theory_1978,
	title = {A theory of type polymorphism in programming},
	volume = {17},
	issn = {00220000},
	url = {https://linkinghub.elsevier.com/retrieve/pii/0022000078900144},
	doi = {10.1016/0022-0000(78)90014-4},
	language = {en},
	number = {3},
	urldate = {2022-01-01},
	journal = {Journal of Computer and System Sciences},
	author = {Milner, Robin},
	month = dec,
	year = {1978},
	pages = {348--375},
	file = {Submitted Version:/Users/rljacobson/Zotero/storage/AY56N59B/Milner - 1978 - A theory of type polymorphism in programming.pdf:application/pdf},
}

@incollection{goos_polymorphic_1984,
	address = {Berlin, Heidelberg},
	title = {Polymorphic type schemes and recursive definitions},
	volume = {167},
	isbn = {978-3-540-12925-7 978-3-540-38809-8},
	url = {http://link.springer.com/10.1007/3-540-12925-1_41},
	urldate = {2022-01-01},
	booktitle = {International {Symposium} on {Programming}},
	publisher = {Springer Berlin Heidelberg},
	author = {Mycroft, Alan},
	editor = {Goos, G. and Hartmanis, J. and Barstow, D. and Brauer, W. and Brinch Hansen, P. and Gries, D. and Luckham, D. and Moler, C. and Pnueli, A. and Seegmüller, G. and Stoer, J. and Wirth, N. and Paul, M. and Robinet, B.},
	year = {1984},
	doi = {10.1007/3-540-12925-1_41},
	note = {Series Title: Lecture Notes in Computer Science},
	pages = {217--228},
}

@inproceedings{clarke_skim_1980,
	address = {Stanford University, California, United States},
	title = {{SKIM} - {The} {S}, {K}, {I} reduction machine},
	url = {http://portal.acm.org/citation.cfm?doid=800087.802798},
	doi = {10.1145/800087.802798},
	language = {en},
	urldate = {2022-01-01},
	booktitle = {Proceedings of the 1980 {ACM} conference on {LISP} and functional programming  - {LFP} '80},
	publisher = {ACM Press},
	author = {Clarke, T. J.W. and Gladstone, P. J.S. and MacLean, C. D. and Norman, A. C.},
	year = {1980},
	pages = {128--135},
}

@inproceedings{scheevel_norma_1986,
	address = {Cambridge, Massachusetts, United States},
	title = {{NORMA}: a graph reduction processor},
	isbn = {978-0-89791-200-6},
	shorttitle = {{NORMA}},
	url = {http://portal.acm.org/citation.cfm?doid=319838.319864},
	doi = {10.1145/319838.319864},
	language = {en},
	urldate = {2022-01-01},
	booktitle = {Proceedings of the 1986 {ACM} conference on {LISP} and functional programming  - {LFP} '86},
	publisher = {ACM Press},
	author = {Scheevel, Mark},
	year = {1986},
	pages = {212--219},
}

@article{schorr_efficient_1967,
	title = {An efficient machine-independent procedure for garbage collection in various list structures},
	volume = {10},
	issn = {0001-0782, 1557-7317},
	url = {https://dl.acm.org/doi/10.1145/363534.363554},
	doi = {10.1145/363534.363554},
	abstract = {A method for returning registers to the free list is an essential part of any list processing system. In this paper, past solutions of the recovery problem are reviewed and compared. A new algorithm is presented which offers significant advantages of speed and storage utilization. The routine for implementing this algorithm can be written in the list language with which it is to be used, thus insuring a degree of machine independence. Finally, the application of the algorithm to a number of different list structures appearing in the literature is indicated.},
	language = {en},
	number = {8},
	urldate = {2022-01-01},
	journal = {Communications of the ACM},
	author = {Schorr, H. and Waite, W. M.},
	month = aug,
	year = {1967},
	pages = {501--506},
}

@inproceedings{stoye_practical_1984,
	address = {Austin, Texas, United States},
	title = {Some practical methods for rapid combinator reduction},
	isbn = {978-0-89791-142-9},
	url = {http://portal.acm.org/citation.cfm?doid=800055.802032},
	doi = {10.1145/800055.802032},
	language = {en},
	urldate = {2022-01-01},
	booktitle = {Proceedings of the 1984 {ACM} {Symposium} on {LISP} and functional programming  - {LFP} '84},
	publisher = {ACM Press},
	author = {Stoye, W. R. and Clarke, T. J. W. and Norman, A. C.},
	year = {1984},
	pages = {159--166},
}

@incollection{goos_lazy_1985,
	address = {Berlin, Heidelberg},
	title = {Lazy memo-functions},
	volume = {201},
	isbn = {978-3-540-15975-9 978-3-540-39677-2},
	url = {http://link.springer.com/10.1007/3-540-15975-4_34},
	urldate = {2022-01-01},
	booktitle = {Functional {Programming} {Languages} and {Computer} {Architecture}},
	publisher = {Springer Berlin Heidelberg},
	author = {Hughes, John},
	editor = {Goos, G. and Hartmanis, J. and Barstow, D. and Brauer, W. and Brinch Hansen, P. and Gries, D. and Luckham, D. and Moler, C. and Pnueli, A. and Seegmüller, G. and Stoer, J. and Wirth, N. and Jouannaud, Jean-Pierre},
	year = {1985},
	doi = {10.1007/3-540-15975-4_34},
	note = {Series Title: Lecture Notes in Computer Science},
	pages = {129--146},
}

@article{de_bruijn_lambda_1972,
	title = {Lambda calculus notation with nameless dummies, a tool for automatic formula manipulation, with application to the {Church}-{Rosser} theorem},
	volume = {75},
	issn = {13857258},
	url = {https://linkinghub.elsevier.com/retrieve/pii/1385725872900340},
	doi = {10.1016/1385-7258(72)90034-0},
	language = {en},
	number = {5},
	urldate = {2022-01-01},
	journal = {Indagationes Mathematicae (Proceedings)},
	author = {de Bruijn, N.G},
	year = {1972},
	pages = {381--392},
	file = {Submitted Version:/Users/rljacobson/Zotero/storage/SXWWG6YK/de Bruijn - 1972 - Lambda calculus notation with nameless dummies, a .pdf:application/pdf},
}

@article{hoffmann_programming_1982,
	title = {Programming with {Equations}},
	volume = {4},
	issn = {0164-0925, 1558-4593},
	url = {https://dl.acm.org/doi/10.1145/357153.357158},
	doi = {10.1145/357153.357158},
	language = {en},
	number = {1},
	urldate = {2022-01-01},
	journal = {ACM Transactions on Programming Languages and Systems},
	author = {Hoffmann, Christoph M. and O'Donnell, Michael J.},
	month = jan,
	year = {1982},
	pages = {83--112},
}

@article{johnsson_efficient_1984-1,
	title = {Efficient compilation of lazy evaluation},
	volume = {19},
	issn = {0362-1340, 1558-1160},
	url = {https://dl.acm.org/doi/10.1145/502949.502880},
	doi = {10.1145/502949.502880},
	abstract = {This paper describes the principles underlying an efficient implementation of a lazy functional language, compiling to code for ordinary computers. It is based on combinator-like graph reduction: the user defined functions are used as rewrite rules in the graph. Each function is compiled into an instruction sequence for an abstract graph reduction machine, called the G-machine, the code reduces a function application graph to its value. The G-machine instructions are then translated into target code. Speed improvements by almost two orders of magnitude over previous lazy evaluators have been measured; we provide some performance figures.},
	language = {en},
	number = {6},
	urldate = {2022-01-01},
	journal = {ACM SIGPLAN Notices},
	author = {Johnsson, Thomas},
	month = jun,
	year = {1984},
	pages = {58--69},
}

@incollection{goos_lambda_1985,
	address = {Berlin, Heidelberg},
	title = {Lambda lifting: {Transforming} programs to recursive equations},
	volume = {201},
	isbn = {978-3-540-15975-9 978-3-540-39677-2},
	shorttitle = {Lambda lifting},
	url = {http://link.springer.com/10.1007/3-540-15975-4_37},
	urldate = {2022-01-01},
	booktitle = {Functional {Programming} {Languages} and {Computer} {Architecture}},
	publisher = {Springer Berlin Heidelberg},
	author = {Johnsson, Thomas},
	editor = {Goos, G. and Hartmanis, J. and Barstow, D. and Brauer, W. and Brinch Hansen, P. and Gries, D. and Luckham, D. and Moler, C. and Pnueli, A. and Seegmüller, G. and Stoer, J. and Wirth, N. and Jouannaud, Jean-Pierre},
	year = {1985},
	doi = {10.1007/3-540-15975-4_37},
	note = {Series Title: Lecture Notes in Computer Science},
	pages = {190--203},
}

@article{landin_mechanical_1964,
	title = {The {Mechanical} {Evaluation} of {Expressions}},
	volume = {6},
	issn = {0010-4620, 1460-2067},
	url = {https://academic.oup.com/comjnl/article-lookup/doi/10.1093/comjnl/6.4.308},
	doi = {10.1093/comjnl/6.4.308},
	language = {en},
	number = {4},
	urldate = {2022-01-01},
	journal = {The Computer Journal},
	author = {Landin, P. J.},
	month = jan,
	year = {1964},
	pages = {308--320},
	file = {Full Text:/Users/rljacobson/Zotero/storage/GW89IUIZ/Landin - 1964 - The Mechanical Evaluation of Expressions.pdf:application/pdf},
}

@book{odonnell_computing_1977,
	address = {Berlin, Heidelberg},
	series = {Lecture {Notes} in {Computer} {Science}},
	title = {Computing in systems described by equations},
	volume = {58},
	isbn = {978-3-540-08531-7 978-3-540-35983-8},
	url = {http://link.springer.com/10.1007/3-540-08531-9},
	urldate = {2022-01-01},
	publisher = {Springer Berlin Heidelberg},
	editor = {O'Donnell, Michael J. and Goos, G. and Hartmanis, J. and Brinch Hansen, P. and Gries, D. and Moler, C. and Seegmüller, G. and Stoer, J. and Wirth, N.},
	year = {1977},
	doi = {10.1007/3-540-08531-9},
}

@inproceedings{hudak_combinator-based_1984,
	address = {Salt Lake City, Utah, United States},
	title = {A combinator-based compiler for a functional language},
	isbn = {978-0-89791-125-2},
	url = {http://portal.acm.org/citation.cfm?doid=800017.800523},
	doi = {10.1145/800017.800523},
	language = {en},
	urldate = {2022-01-01},
	booktitle = {Proceedings of the 11th {ACM} {SIGACT}-{SIGPLAN} symposium on {Principles} of programming languages  - {POPL} '84},
	publisher = {ACM Press},
	author = {Hudak, Paul and Kranz, David},
	year = {1984},
	pages = {122--132},
}

@incollection{goos_serial_1985,
	address = {Berlin, Heidelberg},
	title = {Serial combinators: "optimal" grains of parallelism},
	volume = {201},
	isbn = {978-3-540-15975-9 978-3-540-39677-2},
	shorttitle = {Serial combinators},
	url = {http://link.springer.com/10.1007/3-540-15975-4_49},
	urldate = {2022-01-01},
	booktitle = {Functional {Programming} {Languages} and {Computer} {Architecture}},
	publisher = {Springer Berlin Heidelberg},
	author = {Hudak, Paul and Goldberg, Benjamin},
	editor = {Goos, G. and Hartmanis, J. and Barstow, D. and Brauer, W. and Brinch Hansen, P. and Gries, D. and Luckham, D. and Moler, C. and Pnueli, A. and Seegmüller, G. and Stoer, J. and Wirth, N. and Jouannaud, Jean-Pierre},
	year = {1985},
	doi = {10.1007/3-540-15975-4_49},
	note = {Series Title: Lecture Notes in Computer Science},
	pages = {382--399},
}

@article{burton_linear_1982,
	title = {A linear space translation of functional programs to {Turner} combinators},
	volume = {14},
	issn = {00200190},
	url = {https://linkinghub.elsevier.com/retrieve/pii/002001908290014X},
	doi = {10.1016/0020-0190(82)90014-X},
	language = {en},
	number = {5},
	urldate = {2022-01-01},
	journal = {Information Processing Letters},
	author = {Burton, F.Warren},
	month = jul,
	year = {1982},
	pages = {201--204},
}

@article{joy_efficient_1985,
	title = {Efficient combinator code},
	volume = {10},
	issn = {00960551},
	url = {https://linkinghub.elsevier.com/retrieve/pii/0096055185900177},
	doi = {10.1016/0096-0551(85)90017-7},
	language = {en},
	number = {3-4},
	urldate = {2022-01-01},
	journal = {Computer Languages},
	author = {Joy, M.S. and Rayward-Smith, V.J. and Burton, F.W.},
	month = jan,
	year = {1985},
	pages = {211--224},
}

@article{turner_new_1979,
	title = {A new implementation technique for applicative languages},
	volume = {9},
	issn = {00380644, 1097024X},
	url = {https://onlinelibrary.wiley.com/doi/10.1002/spe.4380090105},
	doi = {10.1002/spe.4380090105},
	language = {en},
	number = {1},
	urldate = {2022-01-01},
	journal = {Software: Practice and Experience},
	author = {Turner, D. A.},
	month = jan,
	year = {1979},
	pages = {31--49},
}

@article{turner_another_1979,
	title = {Another algorithm for bracket abstraction},
	volume = {44},
	issn = {0022-4812, 1943-5886},
	url = {https://www.cambridge.org/core/product/identifier/S0022481200048970/type/journal_article},
	doi = {10.2307/2273733},
	abstract = {This short article presents an algorithm for bracket abstraction [1] which avoids a combinatorial explosion in the size of the resulting expression when applied repeatedly for abstraction in a series of variables. It differs from a previous solution [2] in introducing only a finite number of additional combinators and in not requiring that all the variables to be abstracted be treated together in a single operation.},
	language = {en},
	number = {2},
	urldate = {2022-01-01},
	journal = {Journal of Symbolic Logic},
	author = {Turner, D. A.},
	month = jun,
	year = {1979},
	pages = {267--270},
}

@article{baker_list_1978,
	title = {List processing in real time on a serial computer},
	volume = {21},
	issn = {0001-0782, 1557-7317},
	url = {https://dl.acm.org/doi/10.1145/359460.359470},
	doi = {10.1145/359460.359470},
	abstract = {A real-time list processing system is one in which the time required by the elementary list operations (e.g. CONS, CAR, CDR, RPLACA, RPLACD, EQ, and ATOM in LISP) is bounded by a (small) constant. Classical implementations of list processing systems lack this property because allocating a list cell from the heap may cause a garbage collection, which process requires time proportional to the heap size to finish. A real-time list processing system is presented which continuously reclaims garbage, including directed cycles, while linearizing and compacting the accessible cells into contiguous locations to avoid fragmenting the free storage pool. The program is small and requires no time-sharing interrupts, making it suitable for microcode. Finally, the system requires the same average time, and not more than twice the space, of a classical implementation, and those space requirements can be reduced to approximately classical proportions by compact list representation. Arrays of different sizes, a program stack, and hash linking are simple extensions to our system, and reference counting is found to be inferior for many applications.},
	language = {en},
	number = {4},
	urldate = {2022-01-01},
	journal = {Communications of the ACM},
	author = {Baker, Henry G.},
	month = apr,
	year = {1978},
	pages = {280--294},
	file = {Submitted Version:/Users/rljacobson/Zotero/storage/63IE67RB/Baker - 1978 - List processing in real time on a serial computer.pdf:application/pdf},
}

@article{ben-ari_algorithms_1984,
	title = {Algorithms for on-the-fly garbage collection},
	volume = {6},
	issn = {0164-0925, 1558-4593},
	url = {https://dl.acm.org/doi/10.1145/579.587},
	doi = {10.1145/579.587},
	language = {en},
	number = {3},
	urldate = {2022-01-01},
	journal = {ACM Transactions on Programming Languages and Systems},
	author = {Ben-Ari, Mordechai},
	month = jul,
	year = {1984},
	pages = {333--344},
}

@article{bobrow_managing_1980,
	title = {Managing {Reentrant} {Structures} {Using} {Reference} {Counts}},
	volume = {2},
	issn = {0164-0925, 1558-4593},
	url = {https://dl.acm.org/doi/10.1145/357103.357104},
	doi = {10.1145/357103.357104},
	abstract = {Automatic storage management requires that one identify storage unreachable by a user's program and return it to free status. One technique maintains a count of the references from user's programs to each cell, since a count of zero implies the storage is unreachable. Reentrant structures are self-referencing; hence no cell in them will have a count of zero, even though the entire structure is unreachable. A modification of standard reference counting can be used to manaage the deallocation of a large class of frequently used reentrant structures, including two-way and circularly linked lists.
            All the cells of a potentially reentrant structure are considered as part of a single group for deallocation purposes. Information associated with each cell specifies its group membership. Internal references (pointers from one cell of the group to another) are not reference counted. External references to any cell of this group are counted as references to the group as a whole. When the external reference count goes to zero, all the cells of the group can be deallocated. This paper describes several ways of specifying group membership, properties of each implementation, and properties of mutable and immutable group membership.},
	language = {en},
	number = {3},
	urldate = {2022-01-01},
	journal = {ACM Transactions on Programming Languages and Systems},
	author = {Bobrow, Daniel G.},
	month = jul,
	year = {1980},
	pages = {269--273},
}

@incollection{goos_cyclic_1985,
	address = {Berlin, Heidelberg},
	title = {Cyclic reference counting for combinator machines},
	volume = {201},
	isbn = {978-3-540-15975-9 978-3-540-39677-2},
	url = {http://link.springer.com/10.1007/3-540-15975-4_42},
	urldate = {2022-01-01},
	booktitle = {Functional {Programming} {Languages} and {Computer} {Architecture}},
	publisher = {Springer Berlin Heidelberg},
	author = {Brownbridge, D. R.},
	editor = {Goos, G. and Hartmanis, J. and Barstow, D. and Brauer, W. and Brinch Hansen, P. and Gries, D. and Luckham, D. and Moler, C. and Pnueli, A. and Seegmüller, G. and Stoer, J. and Wirth, N. and Jouannaud, Jean-Pierre},
	year = {1985},
	doi = {10.1007/3-540-15975-4_42},
	note = {Series Title: Lecture Notes in Computer Science},
	pages = {273--288},
}

@article{cohen_garbage_1981,
	title = {Garbage {Collection} of {Linked} {Data} {Structures}},
	volume = {13},
	issn = {0360-0300, 1557-7341},
	url = {https://dl.acm.org/doi/10.1145/356850.356854},
	doi = {10.1145/356850.356854},
	language = {en},
	number = {3},
	urldate = {2022-01-01},
	journal = {ACM Computing Surveys},
	author = {Cohen, Jacques},
	month = sep,
	year = {1981},
	pages = {341--367},
	file = {Full Text:/Users/rljacobson/Zotero/storage/ZM29NFDB/Cohen - 1981 - Garbage Collection of Linked Data Structures.pdf:application/pdf},
}

@article{dijkstra_--fly_1978,
	title = {On-the-fly garbage collection: an exercise in cooperation},
	volume = {21},
	issn = {0001-0782, 1557-7317},
	shorttitle = {On-the-fly garbage collection},
	url = {https://dl.acm.org/doi/10.1145/359642.359655},
	doi = {10.1145/359642.359655},
	abstract = {As an example of cooperation between sequential processes with very little mutual interference despite frequent manipulations of a large shared data space, a technique is developed which allows nearly all of the activity needed for garbage detection and collection to be performed by an additional processor operating concurrently with the processor devoted to the computation proper. Exclusion and synchronization constraints have been kept as weak as could be achieved; the severe complexities engendered by doing so are illustrated.},
	language = {en},
	number = {11},
	urldate = {2022-01-01},
	journal = {Communications of the ACM},
	author = {Dijkstra, Edsger W. and Lamport, Leslie and Martin, A. J. and Scholten, C. S. and Steffens, E. F. M.},
	month = nov,
	year = {1978},
	pages = {966--975},
}

@inproceedings{hudak_distributed_1983,
	address = {Montreal, Quebec, Canada},
	title = {Distributed task and memory management},
	isbn = {978-0-89791-110-8},
	url = {http://portal.acm.org/citation.cfm?doid=800221.806728},
	doi = {10.1145/800221.806728},
	language = {en},
	urldate = {2022-01-01},
	booktitle = {Proceedings of the second annual {ACM} symposium on {Principles} of distributed computing  - {PODC} '83},
	publisher = {ACM Press},
	author = {Hudak, Paul},
	year = {1983},
	pages = {277--289},
}

@incollection{goos_distributed_1985,
	address = {Berlin, Heidelberg},
	title = {A distributed garbage collection algorithm},
	volume = {201},
	isbn = {978-3-540-15975-9 978-3-540-39677-2},
	url = {http://link.springer.com/10.1007/3-540-15975-4_41},
	urldate = {2022-01-01},
	booktitle = {Functional {Programming} {Languages} and {Computer} {Architecture}},
	publisher = {Springer Berlin Heidelberg},
	author = {Hughes, John},
	editor = {Goos, G. and Hartmanis, J. and Barstow, D. and Brauer, W. and Brinch Hansen, P. and Gries, D. and Luckham, D. and Moler, C. and Pnueli, A. and Seegmüller, G. and Stoer, J. and Wirth, N. and Jouannaud, Jean-Pierre},
	year = {1985},
	doi = {10.1007/3-540-15975-4_41},
	note = {Series Title: Lecture Notes in Computer Science},
	pages = {256--272},
}

@inproceedings{kung_efficient_1977,
	address = {Providence, RI, USA},
	title = {An efficient parallel garbage collection system and {ITS} correctness proof},
	url = {http://ieeexplore.ieee.org/document/4567934/},
	doi = {10.1109/SFCS.1977.5},
	urldate = {2022-01-01},
	booktitle = {18th {Annual} {Symposium} on {Foundations} of {Computer} {Science} (sfcs 1977)},
	publisher = {IEEE},
	author = {Kung, H. T. and Song, S. W.},
	month = sep,
	year = {1977},
	pages = {120--131},
}

@article{lieberman_real-time_1983,
	title = {A real-time garbage collector based on the lifetimes of objects},
	volume = {26},
	issn = {0001-0782, 1557-7317},
	url = {https://dl.acm.org/doi/10.1145/358141.358147},
	doi = {10.1145/358141.358147},
	abstract = {In previous heap storage systems, the cost of creating objects and garbage collection is independent of the lifetime of the object. Since objects with short lifetimes account for a large portion of storage use, it is worth optimizing a garbage collector to reclaim storage for these objects more quickly. The garbage collector should spend proportionately less effort reclaiming objects with longer lifetimes. We present a garbage collection algorithm that (1) makes storage for short-lived objects cheaper than storage for long-lived objects, (2) that operates in real time—object creation and access times are bounded, (3) increases locality of reference, for better virtual memory performance, (4) works well with multiple processors and a large address space.},
	language = {en},
	number = {6},
	urldate = {2022-01-01},
	journal = {Communications of the ACM},
	author = {Lieberman, Henry and Hewitt, Carl},
	month = jun,
	year = {1983},
	pages = {419--429},
	file = {Submitted Version:/Users/rljacobson/Zotero/storage/THRAUGKJ/Lieberman and Hewitt - 1983 - A real-time garbage collector based on the lifetim.pdf:application/pdf},
}

@article{steele_multiprocessing_1975,
	title = {Multiprocessing compactifying garbage collection},
	volume = {18},
	issn = {0001-0782, 1557-7317},
	url = {https://dl.acm.org/doi/10.1145/361002.361005},
	doi = {10.1145/361002.361005},
	abstract = {Algorithms for a multiprocessing compactifying garbage collector are presented and discussed. The simple case of two processors, one performing LISP-like list operations and the other performing garbage collection continuously, is thoroughly examined. The necessary capabilities of each processor are defined, as well as interprocessor communication and interlocks. Complete procedures for garbage collection and for standard list processing primitives are presented and thoroughly explained. Particular attention is given to the problems of marking and relocating list cells while another processor may be operating on them. The primary aim throughout is to allow the list processor to run unimpeded while the other processor reclaims list storage The more complex case involving several list processors and one or more garbage collection processors are also briefly discussed.},
	language = {en},
	number = {9},
	urldate = {2022-01-01},
	journal = {Communications of the ACM},
	author = {Steele, Guy L.},
	month = sep,
	year = {1975},
	pages = {495--508},
}

@inproceedings{wadler_listlessness_1984,
	address = {Austin, Texas, United States},
	title = {Listlessness is better than laziness: {Lazy} evaluation and garbage collection at compile-time},
	isbn = {978-0-89791-142-9},
	shorttitle = {Listlessness is better than laziness},
	url = {http://portal.acm.org/citation.cfm?doid=800055.802020},
	doi = {10.1145/800055.802020},
	language = {en},
	urldate = {2022-01-01},
	booktitle = {Proceedings of the 1984 {ACM} {Symposium} on {LISP} and functional programming  - {LFP} '84},
	publisher = {ACM Press},
	author = {Wadler, Philip},
	year = {1984},
	pages = {45--52},
}

@incollection{goos_design_1985,
	address = {Berlin, Heidelberg},
	title = {Design for a multiprocessing heap with on-board reference counting},
	volume = {201},
	isbn = {978-3-540-15975-9 978-3-540-39677-2},
	url = {http://link.springer.com/10.1007/3-540-15975-4_43},
	urldate = {2022-01-01},
	booktitle = {Functional {Programming} {Languages} and {Computer} {Architecture}},
	publisher = {Springer Berlin Heidelberg},
	author = {Wise, David S.},
	editor = {Goos, G. and Hartmanis, J. and Barstow, D. and Brauer, W. and Brinch Hansen, P. and Gries, D. and Luckham, D. and Moler, C. and Pnueli, A. and Seegmüller, G. and Stoer, J. and Wirth, N. and Jouannaud, Jean-Pierre},
	year = {1985},
	doi = {10.1007/3-540-15975-4_43},
	note = {Series Title: Lecture Notes in Computer Science},
	pages = {289--304},
}

@article{wise_one-bit_1977,
	title = {The one-bit reference count},
	volume = {17},
	issn = {0006-3835, 1572-9125},
	url = {http://link.springer.com/10.1007/BF01932156},
	doi = {10.1007/BF01932156},
	language = {en},
	number = {3},
	urldate = {2022-01-01},
	journal = {BIT},
	author = {Wise, David S. and Friedman, Daniel P.},
	month = sep,
	year = {1977},
	pages = {351--359},
}

@inproceedings{fairbairn_code_1986,
	address = {Cambridge, Massachusetts, United States},
	title = {Code generation techniques for functional languages},
	isbn = {978-0-89791-200-6},
	url = {http://portal.acm.org/citation.cfm?doid=319838.319853},
	doi = {10.1145/319838.319853},
	language = {en},
	urldate = {2022-01-01},
	booktitle = {Proceedings of the 1986 {ACM} conference on {LISP} and functional programming  - {LFP} '86},
	publisher = {ACM Press},
	author = {Fairbairn, Jon and Wray, Stuart C.},
	year = {1986},
	pages = {94--104},
}

@article{griss_portable_1981,
	title = {A portable lisp compiler},
	volume = {11},
	issn = {00380644, 1097024X},
	url = {https://onlinelibrary.wiley.com/doi/10.1002/spe.4380110603},
	doi = {10.1002/spe.4380110603},
	language = {en},
	number = {6},
	urldate = {2022-01-01},
	journal = {Software: Practice and Experience},
	author = {Griss, Martin L. and Hearn, Anthony C.},
	month = jun,
	year = {1981},
	pages = {541--605},
}

@article{richards_portability_1971,
	title = {The portability of the {BCPL} compiler},
	volume = {1},
	issn = {00380644, 1097024X},
	url = {https://onlinelibrary.wiley.com/doi/10.1002/spe.4380010204},
	doi = {10.1002/spe.4380010204},
	language = {en},
	number = {2},
	urldate = {2022-01-01},
	journal = {Software: Practice and Experience},
	author = {Richards, M.},
	month = apr,
	year = {1971},
	pages = {135--146},
}

@inproceedings{cardelli_compiling_1984,
	address = {Austin, Texas, United States},
	title = {Compiling a functional language},
	isbn = {978-0-89791-142-9},
	url = {http://portal.acm.org/citation.cfm?doid=800055.802037},
	doi = {10.1145/800055.802037},
	language = {en},
	urldate = {2022-01-01},
	booktitle = {Proceedings of the 1984 {ACM} {Symposium} on {LISP} and functional programming  - {LFP} '84},
	publisher = {ACM Press},
	author = {Cardelli, Luca},
	year = {1984},
	pages = {208--217},
}

@incollection{goos_strictness_1985,
	address = {Berlin, Heidelberg},
	title = {Strictness analysis — a practical approach},
	volume = {201},
	isbn = {978-3-540-15975-9 978-3-540-39677-2},
	url = {http://link.springer.com/10.1007/3-540-15975-4_28},
	urldate = {2022-01-01},
	booktitle = {Functional {Programming} {Languages} and {Computer} {Architecture}},
	publisher = {Springer Berlin Heidelberg},
	author = {Clack, Chris and Peyton Jones, Simon L},
	editor = {Goos, G. and Hartmanis, J. and Barstow, D. and Brauer, W. and Brinch Hansen, P. and Gries, D. and Luckham, D. and Moler, C. and Pnueli, A. and Seegmüller, G. and Stoer, J. and Wirth, N. and Jouannaud, Jean-Pierre},
	year = {1985},
	doi = {10.1007/3-540-15975-4_28},
	note = {Series Title: Lecture Notes in Computer Science},
	pages = {35--49},
}

@inproceedings{cousot_abstract_1977,
	address = {Los Angeles, California},
	title = {Abstract interpretation: a unified lattice model for static analysis of programs by construction or approximation of fixpoints},
	shorttitle = {Abstract interpretation},
	url = {http://portal.acm.org/citation.cfm?doid=512950.512973},
	doi = {10.1145/512950.512973},
	language = {en},
	urldate = {2022-01-01},
	booktitle = {Proceedings of the 4th {ACM} {SIGACT}-{SIGPLAN} symposium on {Principles} of programming languages  - {POPL} '77},
	publisher = {ACM Press},
	author = {Cousot, Patrick and Cousot, Radhia},
	year = {1977},
	pages = {238--252},
	file = {Submitted Version:/Users/rljacobson/Zotero/storage/7FSYH3EG/Cousot and Cousot - 1977 - Abstract interpretation a unified lattice model f.pdf:application/pdf},
}

@inproceedings{hudak_higher-order_1986,
	address = {St. Petersburg Beach, Florida},
	title = {Higher-order strictness analysis in untyped lambda calculus},
	url = {http://portal.acm.org/citation.cfm?doid=512644.512653},
	doi = {10.1145/512644.512653},
	language = {en},
	urldate = {2022-01-01},
	booktitle = {Proceedings of the 13th {ACM} {SIGACT}-{SIGPLAN} symposium on {Principles} of programming languages  - {POPL} '86},
	publisher = {ACM Press},
	author = {Hudak, Paul and Young, Jonathan},
	year = {1986},
	pages = {97--109},
}

@incollection{goos_strictness_1986,
	address = {Berlin, Heidelberg},
	title = {Strictness detection in non-flat domains},
	volume = {217},
	isbn = {978-3-540-16446-3 978-3-540-39786-1},
	url = {http://link.springer.com/10.1007/3-540-16446-4_7},
	urldate = {2022-01-01},
	booktitle = {Programs as {Data} {Objects}},
	publisher = {Springer Berlin Heidelberg},
	author = {Hughes, John},
	editor = {Goos, G. and Hartmanis, J. and Barstow, D. and Brauer, W. and Brinch Hansen, P. and Gries, D. and Luckham, D. and Moler, C. and Pnueli, A. and Seegmüller, G. and Stoer, J. and Wirth, N. and Ganzinger, Harald and Jones, Neil D.},
	year = {1986},
	doi = {10.1007/3-540-16446-4_7},
	note = {Series Title: Lecture Notes in Computer Science},
	pages = {112--135},
}

@incollection{goos_listlessness_1986,
	address = {Berlin, Heidelberg},
	title = {Listlessness is better than laziness {II}: {Composing} listless functions},
	volume = {217},
	isbn = {978-3-540-16446-3 978-3-540-39786-1},
	shorttitle = {Listlessness is better than laziness {II}},
	url = {http://link.springer.com/10.1007/3-540-16446-4_16},
	urldate = {2022-01-01},
	booktitle = {Programs as {Data} {Objects}},
	publisher = {Springer Berlin Heidelberg},
	author = {Wadler, Philip},
	editor = {Goos, G. and Hartmanis, J. and Barstow, D. and Brauer, W. and Brinch Hansen, P. and Gries, D. and Luckham, D. and Moler, C. and Pnueli, A. and Seegmüller, G. and Stoer, J. and Wirth, N. and Ganzinger, Harald and Jones, Neil D.},
	year = {1986},
	doi = {10.1007/3-540-16446-4_16},
	note = {Series Title: Lecture Notes in Computer Science},
	pages = {282--305},
}

@inproceedings{turner_semantic_1981,
	address = {Portsmouth, New Hampshire, United States},
	title = {The semantic elegance of applicative languages},
	isbn = {978-0-89791-060-6},
	url = {http://portal.acm.org/citation.cfm?doid=800223.806766},
	doi = {10.1145/800223.806766},
	language = {en},
	urldate = {2022-01-01},
	booktitle = {Proceedings of the 1981 conference on {Functional} programming languages and computer architecture  - {FPCA} '81},
	publisher = {ACM Press},
	author = {Turner, D. A.},
	year = {1981},
	pages = {85--92},
}

@inproceedings{clack_four-stroke_1986,
	address = {Cambridge, Massachusetts, United States},
	title = {The four-stroke reduction engine},
	isbn = {978-0-89791-200-6},
	url = {http://portal.acm.org/citation.cfm?doid=319838.319865},
	doi = {10.1145/319838.319865},
	language = {en},
	urldate = {2022-01-01},
	booktitle = {Proceedings of the 1986 {ACM} conference on {LISP} and functional programming  - {LFP} '86},
	publisher = {ACM Press},
	author = {Clack, Chris and Peyton Jones, Simon L.},
	year = {1986},
	pages = {220--232},
	file = {Submitted Version:/Users/rljacobson/Zotero/storage/6879L9N7/Clack and Peyton Jones - 1986 - The four-stroke reduction engine.pdf:application/pdf},
}

@inproceedings{darlington_alice_1981,
	address = {Portsmouth, New Hampshire, United States},
	title = {{ALICE} a multi-processor reduction machine for the parallel evaluation {CF} applicative languages},
	isbn = {978-0-89791-060-6},
	url = {http://portal.acm.org/citation.cfm?doid=800223.806764},
	doi = {10.1145/800223.806764},
	language = {en},
	urldate = {2022-01-01},
	booktitle = {Proceedings of the 1981 conference on {Functional} programming languages and computer architecture  - {FPCA} '81},
	publisher = {ACM Press},
	author = {Darlington, John and Reeve, Mike},
	year = {1981},
	pages = {65--76},
}

@incollection{goos_safe_1986,
	address = {Berlin, Heidelberg},
	title = {A safe approach to parallel combinator reduction},
	volume = {213},
	isbn = {978-3-540-16442-5 978-3-540-39782-3},
	url = {http://link.springer.com/10.1007/3-540-16442-1_7},
	urldate = {2022-01-01},
	booktitle = {{ESOP} 86},
	publisher = {Springer Berlin Heidelberg},
	author = {Hankin, Chris L. and Burn, Geoffrey L. and Peyton Jones, Simon L.},
	editor = {Goos, G. and Hartmanis, J. and Barstow, D. and Brauer, W. and Brinch Hansen, P. and Gries, D. and Luckham, D. and Moler, C. and Pnueli, A. and Seegmüller, G. and Stoer, J. and Wirth, N. and Robinet, Bernard and Wilhelm, Reinhard},
	year = {1986},
	doi = {10.1007/3-540-16442-1_7},
	note = {Series Title: Lecture Notes in Computer Science},
	pages = {99--110},
	file = {Full Text:/Users/rljacobson/Zotero/storage/HNRMZT8Q/Hankin et al. - 1986 - A safe approach to parallel combinator reduction (.pdf:application/pdf},
}

@inproceedings{hudak_para-functional_1986,
	address = {St. Petersburg Beach, Florida},
	title = {Para-functional programming: a paradigm for programming multiprocessor systems},
	shorttitle = {Para-functional programming},
	url = {http://portal.acm.org/citation.cfm?doid=512644.512667},
	doi = {10.1145/512644.512667},
	abstract = {One of the most important pragmatic advantages of functional languages is that concurrency in a program is \textit{implicit} -- there is no need for special constructs to express parallelism as is required in most conventional languages. Furthermore, it is fairly easy for compilers to automatically determine the concurrency as a step toward decomposing a program for execution on a suitable parallel architecture. Yet it is often the case that one knows precisely the \textit{optimal decomposition} for execution on a particular machine, and one can never expect a compiler to determine such optimal mappings in all cases. This paper is concerned with ways to allow the programmer to \textit{explicitly} express this mapping of program to machine, by using annotations that, given a few minor constraints, cannot alter the functional semantics of the program. We show through several detailed examples the expressiveness and conciseness of the resulting "para-functional" programming methodology, using an experimental language called \textit{ParAlfl} based on our ideas. We also give a formal denotational description of the mapping semantics using a notion of \textit{execution trees.}This research was supported in part by NSF Grants DCR-8403304 and DCR-8451415, and a Faculty Development Award from IBM.},
	language = {en},
	urldate = {2022-01-01},
	booktitle = {Proceedings of the 13th {ACM} {SIGACT}-{SIGPLAN} symposium on {Principles} of programming languages  - {POPL} '86},
	publisher = {ACM Press},
	author = {Hudak, Paul and Smith, Lauren},
	year = {1986},
	pages = {243--254},
}

@article{hudak_distributed_1985,
	title = {Distributed execution of functional programs using serial combinators},
	volume = {C-34},
	issn = {0018-9340},
	url = {http://ieeexplore.ieee.org/document/6312191/},
	doi = {10.1109/TC.1985.6312191},
	number = {10},
	urldate = {2022-01-01},
	journal = {IEEE Transactions on Computers},
	author = {Hudak, Paul and Goldberg, Benjamin},
	month = oct,
	year = {1985},
	pages = {881--891},
}

@article{keller_simulated_1984,
	title = {Simulated {Performance} of a {Reduction}-{Based} {Multiprocessor}},
	volume = {17},
	issn = {0018-9162},
	url = {http://ieeexplore.ieee.org/document/1659188/},
	doi = {10.1109/MC.1984.1659188},
	number = {7},
	urldate = {2022-01-01},
	journal = {Computer},
	author = {{Keller} and {Lin}},
	month = jul,
	year = {1984},
	pages = {70--82},
}

@inproceedings{keller_loosely-coupled_1979,
	address = {New York, NY, USA},
	title = {A loosely-coupled applicative multi-processing system},
	isbn = {978-1-5090-3181-8},
	url = {https://ieeexplore.ieee.org/document/8817294/},
	doi = {10.1109/MARK.1979.8817294},
	urldate = {2022-01-01},
	booktitle = {1979 {International} {Workshop} on {Managing} {Requirements} {Knowledge} ({MARK})},
	publisher = {IEEE},
	author = {Keller, Robert M. and Lindstrom, Gary and Patil, Suhas},
	month = jun,
	year = {1979},
	pages = {613--622},
}

@article{peyton_jones_using_1986,
	title = {Using {Futurebus} in a fifth-generation computer},
	volume = {10},
	issn = {01419331},
	url = {https://linkinghub.elsevier.com/retrieve/pii/0141933186900293},
	doi = {10.1016/0141-9331(86)90029-3},
	language = {en},
	number = {2},
	urldate = {2022-01-01},
	journal = {Microprocessors and Microsystems},
	author = {Peyton Jones, Simon},
	month = mar,
	year = {1986},
	pages = {69--76},
}

@article{smith_cache_1982,
	title = {Cache {Memories}},
	volume = {14},
	issn = {0360-0300, 1557-7341},
	url = {https://dl.acm.org/doi/10.1145/356887.356892},
	doi = {10.1145/356887.356892},
	language = {en},
	number = {3},
	urldate = {2022-01-01},
	journal = {ACM Computing Surveys},
	author = {Smith, Alan Jay},
	month = sep,
	year = {1982},
	pages = {473--530},
}

@article{richards_overview_1984,
	title = {An overview of {ARC} {SASL}},
	volume = {19},
	issn = {0362-1340, 1558-1160},
	url = {https://dl.acm.org/doi/10.1145/948290.948294},
	doi = {10.1145/948290.948294},
	language = {en},
	number = {10},
	urldate = {2022-01-01},
	journal = {ACM SIGPLAN Notices},
	author = {Richards, H.},
	month = oct,
	year = {1984},
	pages = {40--45},
}

@inproceedings{thompson_laws_1986,
	address = {Cambridge, Massachusetts, United States},
	title = {Laws in {Miranda}},
	isbn = {978-0-89791-200-6},
	url = {http://portal.acm.org/citation.cfm?doid=319838.319839},
	doi = {10.1145/319838.319839},
	language = {en},
	urldate = {2022-01-01},
	booktitle = {Proceedings of the 1986 {ACM} conference on {LISP} and functional programming  - {LFP} '86},
	publisher = {ACM Press},
	author = {Thompson, Simon},
	year = {1986},
	pages = {1--12},
}

@techreport{cardelli_functional_1983,
	address = {Murray Hill, New Jersey 07974},
	title = {The {Functional} {Abstract} {Machine}},
	number = {107},
	institution = {Bell Laboratories},
	author = {Cardelli, L.},
	year = {1983},
	note = {Series: Computing Science Technical Report},
	pages = {45},
	file = {Cardelli - The Functional Abstract Machine.pdf:/Users/rljacobson/Zotero/storage/8DIEKPP3/Cardelli - The Functional Abstract Machine.pdf:application/pdf},
}

@techreport{fairbairn_ponder_1982,
	address = {Cambridge, United Kingdom},
	title = {Ponder {And} {Its} {Type} {System}},
	url = {https://www.cl.cam.ac.uk/techreports/UCAM-CL-TR-31.pdf},
	number = {31},
	institution = {University of Cambridge},
	author = {Fairbairn, Jon},
	month = nov,
	year = {1982},
	note = {ISSN 1476-2986},
	pages = {44},
	file = {Fairbairn - Ponder and its type system.pdf:/Users/rljacobson/Zotero/storage/PT2IHNFK/Fairbairn - Ponder and its type system.pdf:application/pdf},
}

@article{steele_debunking_1977,
	title = {Debunking the '{Expensive} {Procedure} {Call}' {Myth}, or, {Procedure} {Call} {Implementations} {Considered} {Harmful}, or, {Lambda}: {The} {Ultimate} {GOTO}},
	shorttitle = {Debunking the '{Expensive} {Procedure} {Call}' {Myth}, or, {Procedure} {Call} {Implementations} {Considered} {Harmful}, or, {Lambda}},
	url = {https://dspace.mit.edu/handle/1721.1/5753},
	abstract = {Folklore states that GOTO statements are 'cheap', while procedure calls are 'expensive'. This myth is largely a result of poorly designed language implementations. The historical growth of this myth is considered. Both theoretical ideas and an existing implementation are discussed which debunk this myth. It is shown that the unrestricted use of procedure calls permits great stylistic freedom. In particular, any flowchart can be written as a 'structured' program without introducing extra variables. The difficulty with the GOTO statement and the procedure call is characterized as a conflict between abstract programming concepts and concrete language constructs.},
	language = {en\_US},
	urldate = {2022-01-01},
	author = {Steele, Guy Lewis},
	month = oct,
	year = {1977},
	note = {Accepted: 2004-10-01T20:34:01Z},
	file = {Full Text PDF:/Users/rljacobson/Zotero/storage/TD7DPYRH/Steele - 1977 - Debunking the 'Expensive Procedure Call' Myth, or,.pdf:application/pdf;Snapshot:/Users/rljacobson/Zotero/storage/SK8FP82C/5753.html:text/html},
}

@article{burn_strictness_1986,
	title = {Strictness analysis for higher-order functions},
	volume = {7},
	issn = {0167-6423},
	url = {https://www.sciencedirect.com/science/article/pii/0167642386900109},
	doi = {https://doi.org/10.1016/0167-6423(86)90010-9},
	abstract = {Abstract interpretation is a compile-time technique which is used to gain information about a program that may then be used to optimise the execution of the program. A particular use of abstract interpretation is the strictness analysis of functional programs. This provides the key to the exploitation of parallelism in the evaluation of programs written in functional languages. In a language that has lazy semantics, the main potential for parallelism arises in the evaluation of operands of strict operators. A function is strict in an argument if its value is undefined whenever the argument is undefined. If we can use strictness analysis to detect which arguments a function is strict in, we then know that these arguments can be safely evaluated in parallel because this will not affect the lazy semantics. Experimental results suggest that this leads to significant speed-ups. Mycroft was the first person to apply abstract interpretation to the strictness analysis of functional programs. His framework only applies to first-order functions on flat domains. Many workers have proposed practical approaches to strictness analysis of higher-order functions over flat base domains but their work has not been accompanied by extensions to Mycroft's theoretical framework. In this paper we give sound mathematical foundations for this work and discuss some of the practical issues involved. The practical approach is proved correct in relation to the theoretical framework.},
	journal = {Science of Computer Programming},
	author = {Burn, Geoffrey L. and Hankin, Chris and Abramsky, Samson},
	year = {1986},
	pages = {249--278},
}

@phdthesis{mycroft_abstract_1982,
	type = {Ph.{D}.},
	title = {Abstract interpretation and optimising transformations for applicative programs},
	url = {https://era.ed.ac.uk/handle/1842/6602},
	abstract = {This thesis describes methods for transforming applicative 
programs with the aim of improving their efficiency. The general 
justification for these techniques is presented via the concept of 
abstract interpretation. The work can be seen as providing 
mechanisms to optimise applicative programs for sequential von 
Neumann machines. The chapters address the following subjects. 
Chapter 1 gives an overview and gentle introduction to the 
following technical chapters. 
Chapter 2 gives an introduction to and motivation for the 
concept of abstract interpretation necessary for the detailed 
understanding of the rest of the work. It includes certain 
theoretical developments, of which I believe the most important is 
the incorporation of the concept of partial functions into our 
notion of abstract interpretation. This is done by associating 
non-standard denotations with functions just as denotational 
semantics gives the standard denotations. 
Chapter 3 gives an example of the ease with which we can talk 
about function objects within abstract interpretive schemes. It 
uses this to show how a simple language using call-by-need 
semantics can be augmented with a system that annotates places in a 
program at which call-by-value can be used without violating the 
call-by-need semantics. 
Chapter 4 extends the work of chapter 3 by showing that under 
some sequentiality restriction, the incorporation of call-by-value 
for call-by-need can be made complete in the sense that the 
resulting program will only possess strict functions except for the 
conditional. 
Chapter 5 is an attempt to apply the concepts of abstract 
interpretation to a completely different problem, that of 
incorporating destructive operators into an applicative program. 
We do this in order to increase the efficiency of implementation 
without violating the applicative semantics by introducing 
destructive operators into our language. 
Finally, chapter 6 contains a discussion of the implications of 
such techniques for real languages, and in particular presents 
arguments whereby applicative languages should be seen as whole 
systems and not merely the applicative subset of some larger 
language.},
	language = {en},
	urldate = {2022-01-01},
	school = {The University of Edinburgh},
	author = {Mycroft, Alan},
	year = {1982},
	note = {Accepted: 1981
Publisher: The University of Edinburgh},
	file = {Full Text PDF:/Users/rljacobson/Zotero/storage/Y5IEDU3Z/Mycroft - 1982 - Abstract interpretation and optimising transformat.pdf:application/pdf;Snapshot:/Users/rljacobson/Zotero/storage/4VX2IHZU/6602.html:text/html},
}

@book{stoy_denotational_1977,
	address = {Cambridge, MA, USA},
	title = {Denotational {Semantics}: {The} {Scott}-{Strachey} {Approach} to {Programming} {Language} {Theory}},
	isbn = {978-0-262-19147-0},
	shorttitle = {Denotational {Semantics}},
	abstract = {From the Publisher: "First book-length exposition of the denotational (or `mathematical' or `functional') approach to the formal semantics of programming languages (in contrast to `operational' and `axiomatic' approaches). Treats various kinds of languages, beginning with the pure-lambda-calculus and progressing through languages with states, commands, jumps, and assignments. This somewhat discursive account is a valuable compilation of results not otherwise available in a single source." -- American Mathematical Monthly},
	publisher = {MIT Press},
	author = {Stoy, Joseph E.},
	year = {1977},
}

@book{abramsky_abstract_1987,
	address = {USA},
	title = {Abstract interpretation of declarative languages},
	isbn = {978-0-7458-0109-4},
	publisher = {Halsted Press},
	editor = {Abramsky, S. and Hankin, C.},
	year = {1987},
}

@incollection{abramsky_strictness_1987,
	address = {USA},
	title = {Strictness {Analysis} on {Non}-flat {Domains}},
	isbn = {978-0-7458-0109-4},
	booktitle = {Abstract interpretation of declarative languages},
	publisher = {Halsted Press},
	author = {Wadler, Philip},
	editor = {Abramsky, S. and Hankin, C.},
	year = {1987},
}

@phdthesis{wray_implementation_1986,
	address = {Cambridge, United Kingdom},
	type = {{PhD}},
	title = {Implementation and programming techniques for functional languages},
	school = {University of Cambridge},
	author = {Wray, Stuart C.},
	month = jan,
	year = {1986},
}

@book{hughes_parallel_1984,
	address = {Oxford},
	title = {Parallel {Functional} {Programs} use {Less} {Space}},
	language = {en},
	publisher = {Programming Research Group},
	author = {Hughes, R.J.M.},
	year = {1984},
}

@phdthesis{meira_efficiency_1985,
	type = {Ph.{D}.},
	title = {On the efficiency of applicative algorithms},
	url = {https://ethos.bl.uk/OrderDetails.do?uin=uk.bl.ethos.353183},
	abstract = {Computer software \& programming},
	language = {eng},
	urldate = {2022-01-02},
	school = {University of Kent},
	author = {Meira, Silvio Romero de Lemos},
	year = {1985},
	note = {Accepted: 1985},
	file = {Snapshot:/Users/rljacobson/Zotero/storage/WTAGEBNZ/OrderDetails.html:text/html},
}

@techreport{stoye_implementation_1985,
	type = {{PhD} {Thesis}},
	title = {The implementation of functional languages using custom hardware},
	url = {https://www.cl.cam.ac.uk/techreports/UCAM-CL-TR-81.html},
	language = {en},
	number = {UCAM-CL-TR-81},
	urldate = {2022-01-02},
	institution = {University of Cambridge, Computer Laboratory},
	author = {Stoye, William Robert},
	month = dec,
	year = {1985},
	note = {Submitted May 1985},
	pages = {151},
	file = {Full Text PDF:/Users/rljacobson/Zotero/storage/MPUC5RIZ/Stoye - 1985 - The implementation of functional languages using c.pdf:application/pdf;Snapshot:/Users/rljacobson/Zotero/storage/A2ZPRWVG/UCAM-CL-TR-81.html:text/html},
}

@inproceedings{clack_generating_1985,
	title = {Generating parallelism from strictness analysis},
	language = {en},
	booktitle = {Proc. {Workshop} on {Implementation} of {Functional} {Languages}},
	publisher = {Chalmers University of Technology \& University of Goteborg},
	author = {Clack, Chris and Peyton-Jones, Simon L.},
	month = feb,
	year = {1985},
	note = {Type: Report 17,},
	pages = {92--131,},
}

@misc{cripps_asynchronous_1983,
	title = {An {Asynchronous} {Structure}-independent {Switching} {System} with {System}-level {Fault} {Tolerance}},
	language = {en},
	publisher = {Dept Comp. Sci., Imperial College, London},
	author = {Cripps, M.D. and Field, A.J.},
	year = {1983},
	note = {Place: Dept Comp. Sci., Imperial College, London},
}

@inproceedings{denning_modeling_1971,
	address = {New York, NY, USA},
	series = {{AFIPS} '72 ({Spring})},
	title = {On modeling program behavior},
	isbn = {978-1-4503-7909-0},
	url = {https://doi.org/10.1145/1478873.1478998},
	doi = {10.1145/1478873.1478998},
	abstract = {This is a paper about the history of the working set model for program behavior. It traces briefly the origins and bases of the idea and some of the results subsequently obtained. The physical context is a hierarchical memory system consisting of a severely limited quantity of main (directly-addressable) storage and an essentially unlimited quantity of secondary (backup) storage. In this context, the intuitive notion of "working information" as the set of words which are (or should be) loaded in main memory at any given time in order that a program may operate efficiently is as old as programming itself. The sharply increased interest in program models since the mid-1960s is a direct consequence of the widening use of virtual memory and multiprogramming techniques, which have shifted the responsibility of memory management from programmers to machines. I am assuming here that the purpose of memory management is ensuring that an active program's working information is present in main memory, and the purpose of a program model is providing a basis for determining a program's working information at a given time and predicting what it will be at a future time.},
	urldate = {2022-01-01},
	booktitle = {Proceedings of the {May} 16-18, 1972, spring joint computer conference},
	publisher = {Association for Computing Machinery},
	author = {Denning, Peter J.},
	month = nov,
	year = {1971},
	pages = {937--944},
}

@techreport{hudak_distributed_1984,
	type = {Technical {Report}},
	title = {Distributed {Applicative} {Processing} {Systems}: {Project} {Goals}, {Motivation}, and {Status}},
	url = {http://www.cs.yale.edu/publications/techreports/tr317.pdf},
	number = {317},
	urldate = {2022-01-02},
	institution = {Department of Computer Science, Yale University},
	author = {Hudak, Paul},
	month = may,
	year = {1984},
	file = {tr317.pdf:/Users/rljacobson/Zotero/storage/248YRJUN/tr317.pdf:application/pdf},
}

@article{goldberg_serial_1985,
	series = {Springer-{Verlag} lecture notes in computer science},
	title = {Serial combinators: "{Optimal}" grains of parellelism},
	volume = {201},
	shorttitle = {Serial combinators},
	journal = {Proceedings of IFIP Conference on Functional Programming Languages and Computer Architecture,September 1985},
	author = {Goldberg, Benjamin and Hudak, Paul},
	year = {1985},
	note = {Publisher: Springer Verlag},
	pages = {382--389},
}
